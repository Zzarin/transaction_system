# transaction_system

### Нужно реализовать систему транзакций.
#### Как происходит транзакция:
Идет запрос на сервер от клиента, по клиенту выстраивается очередь на вывод.
 **Важно:**
1) у каждого клиента есть своя очередь; 
2) при нехватке денег, нужно блокировать запрос
#### Что нужно реализовать :
* бд на postgresql, где будет схема с клиентами и их балансами
* сервер, который проверяет все условия(хватает ли денег, если сервер упадет, то история, которая идет на вывод 
не должна пропасть) и делает изменение баланса(на + или -)

### Реализация:
**Используемые библиотеки:**
* Go-flags для парсинга переменных окружения в которых находятся настройки подключения
* Zap logger конфигурируемый и быстрый логер. Заменяет стандартный устраняя неявную зависимость 
* Pq драйвер БД postgresSQL. Требование задания
* SQLX надстройка над стандартным пакетом sql для упрощения парсинга выборки из БД в структуры
* amqp091-go клиент брокера сообщений RabbitMQ. Нужен для организации очереди на каждого клиента и асинхронной записи 
транзакций.

#### Текущее состояние
Выбрана гексагональная архитектура для проекта так как легко масштабируется и тестируется, соблюдается принцип 
инверсии зависимостей. В папке ***cmd\app*** лежит код связанный с запуском приложения. В папке ***internal*** все 
сущности проекта. 
RabbitMQ был выбран в качестве решения так как легко настраивается из коробки и предоставляет функции по автоматическим
ретраям и добавлении в очередь если задача не выполнилась. Диспетчер (exchange) установлен в тип Direct, т.е. идет 
сравнение ***Routing key == Binding key***. Если ключи совпадают, то сообщение попадает в ту очередь которой 
соответствует ключ сообщения. Параметр ***Durable*** в true. Таким образом при сбоях сервера приложения или 
RabbitMQ сообщения не потеряются и будут сохранены. Параметр auto-ack в false - ручное подтверждение выполнение 
задачи, так как в противном случае задача считается выполненной после того как покинула очередь.
На данном этапе в коде ошибки связанные с работой брокера очередей. При поступлении задачи 
с тем же ключом выбрасывается исключение, что невозможно привязать задачу с этим ключом к уже существующей очереди.
При запросе на выполнение транзакции выполняется POST запрос http://{domain}/pay/?client={clientID}, json-данные в 
теле сообщения имеют следующий вид:
```
{
"clientName": "mark",
"orderID": 2134,
"typeTXN": "deposit",
"amount": 2500.00
}
```
При удачном выполнении запроса отправляется код-ответа "200".


#### Дальнейшее улучшение
1) Устранение багов с очередью
2) Написание тестов
3) Сборка через Docker-compose
4) Расширение функционала